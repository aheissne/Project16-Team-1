<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Scaffwording - Learn Meaning</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 0;
      background:#4a4a4a;
      display:flex; justify-content:center; align-items:center;
      min-height:100vh;
    }
    .container {
      background:#fff; padding:20px; border-radius:15px;
      width:min(900px,94vw); box-shadow:0 6px 24px rgba(0,0,0,.25);
    }
    .question { font-size:44px; text-align:center; margin:8px 0 10px; font-weight:700; }

    /* Hint card */
    .hint-card {
      margin:12px auto 18px; max-width:720px;
      padding:16px 18px 18px; border:1px solid #cfe0ff; border-radius:14px;
      background:#f3f7ff; box-shadow:0 4px 14px rgba(26,115,232,.08);
      position:relative; animation:hintIn .25s ease-out;
    }
    @keyframes hintIn { from{transform:translateY(-6px);opacity:0} to{transform:none;opacity:1} }
    .hint-badge {
      position:absolute; top:-12px; left:16px; background:#1a73e8; color:#fff;
      font-size:12px; font-weight:bold; letter-spacing:.02em; padding:4px 10px;
      border-radius:999px; box-shadow:0 2px 8px rgba(26,115,232,.25);
    }
    .hint-type { opacity:.9; margin-left:6px; font-weight:600; }
    .hint-text { color:#243b66; font-size:20px; line-height:1.45; text-align:center; padding:8px 4px 4px; }
    .hint-footer { margin-top:10px; display:flex; justify-content:center; gap:10px; }

    .speak-btn, .hint-listen {
      background:#1a73e8; color:#fff; border:none; padding:10px 16px;
      border-radius:10px; cursor:pointer; font-size:16px; display:block; margin:8px auto; transition:.2s;
    }
    .speak-btn:hover, .hint-listen:hover { background:#155fc7; }

    #hintArea img { max-width:280px; border-radius:10px; display:block; margin:0 auto; }
    .hint-controls { margin-top:6px; display:flex; justify-content:center; gap:8px; }
    .hint-btn { padding:6px 10px; border:1px solid #ccc; border-radius:6px; background:#fff; cursor:pointer; }

    .options { display:grid; grid-template-columns:1fr 1fr; gap:14px; text-align:center; padding:0 20px; }
    .option-btn {
      padding:16px; border:1px solid #ddd; border-radius:12px; background:#fff;
      cursor:pointer; font-size:22px; transition:.2s;
    }
    .option-btn:hover { background:#eef3ff; border-color:#1a73e8; }
    .option-btn.correct { background:#34a853; color:#fff; border-color:#34a853; }
    .option-btn.incorrect { background:#ea4335; color:#fff; border-color:#ea4335; }
    .option-btn.disabled { cursor:not-allowed; opacity:.7; }
    .footer { text-align:center; color:#777; margin-top:12px; }
    /* === Beautiful XP Bar === */
        .xp-progress{
            height:10px;
            background:#e0e0e0;
            border-radius:6px;
            overflow:hidden;
            margin-top:2px;
            box-shadow:inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .xp-fill{
            height:100%;
            background:linear-gradient(to right,#34a853,#5dd46c);
            width:0%;
            border-radius:6px;
            transition:width 0.8s ease-out;
            box-shadow:0 2px 4px rgba(52,168,83,0.3);
        }
        .xp-bar {
    width: 100%;
    max-width: 600px;
    margin: 0 auto 24px auto;
    text-align: center;
    font-weight: bold;
    color: #1a73e8;
}
  </style>
</head>
<body>
  <div class="container">
    <div class="xp-bar" id="xpDisplay">
        Loading XP...
        </div>
    <div class="question"><span id="currentWord">_____</span> means?</div>

    <div id="hintArea">
      <div style="color:#5a6; background:#eef3ff; border:1px solid #dfe6ff; padding:8px 12px; display:inline-block; border-radius:10px;">
        Fetching a helpful hintâ€¦
      </div>
    </div>
    <button id="speakBtn" class="speak-btn" style="display:none;">ðŸ”Š Listen</button>

    <div id="options" class="options"></div>
    <div id="progress" class="footer"></div>
  </div>

  <script>
    const API = "http://localhost:5001";

    async function getRanked(wordId) {
      try {
        const r = await fetch(`${API}/get_ranked_hint_type`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ word_id: Number(wordId) })
        });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const j = await r.json();
        const arr = Array.isArray(j.ranked_hint_types) ? j.ranked_hint_types : [];
        return arr.length ? arr : ["dialogue","context","story","gif"];
      } catch (e) {
        console.warn("[getRanked] fallback:", e);
        return ["dialogue","context","story","gif"];
      }
    }

    async function sendOutcome(wordId, hintType, isCorrect, attempt) {
      try {
        await fetch(`${API}/update_model`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            word_id: Number(wordId),
            hint_type: String(hintType),
            reward: isCorrect ? 1 : 0,
            attempt
          })
        });
      } catch (e) {
        console.warn("[sendOutcome] offline:", e);
      }
    }

    const params = new URLSearchParams(location.search);
    let currentIndex = Number(params.get('index') || '0');

    const $speakBtn = document.getElementById('speakBtn');
    const $currentWord = document.getElementById('currentWord');
    const $hintArea = document.getElementById('hintArea');
    const $options = document.getElementById('options');
    const $progress = document.getElementById('progress');

    let lastHintType = null;
    let hintQueue = [];
    let hintIndex = -1;

    const ATTEMPTS_KEY = 'attemptsMap';
    let attemptsMap = JSON.parse(localStorage.getItem(ATTEMPTS_KEY) || '{}');
    function getAttempts(id){ return Number(attemptsMap[id] || 0); }
    function setAttempts(id,n){ attemptsMap[id] = n; localStorage.setItem(ATTEMPTS_KEY, JSON.stringify(attemptsMap)); }
    const maxAttempts = 3;

    function speak(text) {
      try {
        window.speechSynthesis?.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 1.1;
        $speakBtn.textContent = 'ðŸ”Š Speakingâ€¦';
        $speakBtn.disabled = true;
        u.onend = () => { $speakBtn.textContent = 'ðŸ”Š Listen Again'; $speakBtn.disabled = false; };
        u.onerror = () => { $speakBtn.textContent = 'ðŸ”Š Listen'; $speakBtn.disabled = false; };
        speechSynthesis.speak(u);
      } catch(e) {}
    }

    function setSpeakTarget(textOrNull) {
      if (textOrNull && textOrNull.trim()) {
        $speakBtn.style.display = '';
        $speakBtn.onclick = () => speak(textOrNull);
      } else {
        $speakBtn.style.display = 'none';
        $speakBtn.onclick = null;
      }
    }

    async function loadWords() {
      try { const r = await fetch('words.json'); return await r.json(); }
      catch { return {}; }
    }

    // Render current hint and wire ðŸ”Š for dialogue/story
    async function showCurrentHint(entry, wordText) {
      const type = hintQueue[hintIndex];
      lastHintType = type;
      $hintArea.innerHTML = '';

      const card = document .createElement('div');
      card.className = 'hint-card';

      const badge = document.createElement('div');
      badge.className = 'hint-badge';
      badge.innerHTML = `Hint <span class="hint-type">â€¢ ${type.charAt(0).toUpperCase() + type.slice(1)}</span>`;
      card.appendChild(badge);

      if (type !== 'gif') {
        const txt = entry.hints?.[type] || '(no hint text found)';
        const body = document.createElement('div');
        body.className = 'hint-text';
        body.textContent = txt;
        card.appendChild(body);

        const footer = document.createElement('div');
        footer.className = 'hint-footer';
        card.appendChild(footer);

        if (type === 'dialogue' || type === 'story') {
          setSpeakTarget(txt);
          $speakBtn.classList.add('hint-listen');
          footer.appendChild($speakBtn);
          $speakBtn.style.display = '';
        } else {
          setSpeakTarget(null);
        }

      } else {
        const gifUrl = entry.hints?.gif;
        if (!gifUrl) {
          const body = document.createElement('div');
          body.className = 'hint-text';
          body.textContent = 'No GIF available.';
          card.appendChild(body);
        } else {
          const img = document.createElement('img');
          img.src = gifUrl;
          img.alt = `${wordText} visual hint (animated)`;
          card.appendChild(img);

          const footer = document.createElement('div');
          footer.className = 'hint-footer';
          const btn = document.createElement('button');
          btn.className = 'hint-btn';
          btn.textContent = 'Pause';
          btn.onclick = (e) => {
            e.stopPropagation();
            const paused = img.style.visibility === 'hidden';
            img.style.visibility = paused ? 'visible' : 'hidden';
            btn.textContent = paused ? 'Pause' : 'Play';
          };
          footer.appendChild(btn);
          card.appendChild(footer);
        }
        setSpeakTarget(null);
      }

      $hintArea.appendChild(card);
    }

    async function checkAnswer(clickedBtn, chosenLetter, correctLetter, wordId, entry) {
      window.speechSynthesis?.cancel();
      $speakBtn.textContent = 'ðŸ”Š Listen';
      $speakBtn.disabled = false;

      const optionBtns = document.querySelectorAll('.option-btn');
      optionBtns.forEach(b => b.classList.remove('correct','incorrect','disabled'));

      const isCorrect = (chosenLetter === correctLetter);
      if (getAttempts(wordId) >= maxAttempts) return;

      const attemptNum = getAttempts(wordId) + 1;
      setAttempts(wordId, attemptNum);

      if (hintIndex >= 0 && lastHintType) {
        await sendOutcome(wordId, lastHintType, isCorrect, attemptNum);
      }

            if (isCorrect) {
        clickedBtn.classList.add('correct', 'disabled');

        // ---- NEW: show a clear "Correct!" message ----
        const feedback = document.createElement('div');
        feedback.textContent = 'âœ“ Correct!';
        feedback.style.cssText = `
          margin: 20px auto;
          padding: 14px 20px;
          background: #d4edda;
          color: #155724;
          border: 1px solid #c3e6cb;
          border-radius: 10px;
          font-size: 28px;
          font-weight: bold;
          text-align: center;
          max-width: 400px;
          animation: hintIn .4s ease-out;
        `;
        $hintArea.appendChild(feedback);

        // update score and learned words exactly like before
        const s = (Number(localStorage.getItem('quizScore')) || 0) + 1;
        localStorage.setItem('quizScore', String(s));
        setAttempts(wordId, 0);

        {
          const list = new Set(JSON.parse(localStorage.getItem('learnedWords') || '[]'));
          if (entry.word) list.add(entry.word);
          localStorage.setItem('learnedWords', JSON.stringify([...list]));
        }

        addXP(25);                       // â† NEW LINE

        // wait 1.8 seconds so the user can see the feedback, then go to next word
        setTimeout(() => {
          currentIndex += 1;
          const total = Math.min(
            Number(localStorage.getItem('maxQuestions')) || 0,
            (JSON.parse(localStorage.getItem('shuffledWordIds')) || []).length
          );
          if (currentIndex >= total) window.location.href = 'learn-quiz-complete.html';
          else window.location.href = `learn-quiz.html?index=${currentIndex}`;
        }, 1800);  // 1.8 seconds â€“ feels natural
        return;
      
    

      /*if (isCorrect) {
        clickedBtn.classList.add('correct','disabled');
        const s = (Number(localStorage.getItem('quizScore')) || 0) + 1;
        localStorage.setItem('quizScore', String(s));
        setAttempts(wordId, 0);
       
        {
        const list = new Set(JSON.parse(localStorage.getItem('learnedWords') || '[]'));
        if (entry.word) list.add(entry.word);
        localStorage.setItem('learnedWords', JSON.stringify([...list]));
      }*/

        setTimeout(() => {
          currentIndex += 1;
          const total = Math.min(Number(localStorage.getItem('maxQuestions')) || 0,
                                 (JSON.parse(localStorage.getItem('shuffledWordIds')) || []).length);
          if (currentIndex >= total) window.location.href = 'learn-quiz-complete.html';
          else window.location.href = `learn-quiz.html?index=${currentIndex}`;
        }, 300);
        return;
      }

      clickedBtn.classList.add('incorrect','disabled');
      const triesLeft = Math.max(0, maxAttempts - attemptNum);
      $progress.textContent = `Question ${currentIndex + 1} Â· Attempts left: ${triesLeft}`;

      if (attemptNum >= maxAttempts) {
        optionBtns.forEach(b => { b.classList.add('disabled'); b.disabled = true; });

        const defText = entry.definition ??
          (Array.isArray(entry.choices) && Number.isInteger(entry.correct_index)
            ? entry.choices[entry.correct_index]
            : '(definition unavailable)');
          //  record this question as incorrect (store by question index)
  const inc = new Set(JSON.parse(localStorage.getItem('incorrectWords') || '[]'));
  inc.add(currentIndex);
  localStorage.setItem('incorrectWords', JSON.stringify([...inc]));


        const defBox = document.createElement('div');
        defBox.style.marginTop = '15px';
        defBox.style.padding = '10px';
        defBox.style.border = '1px solid #ccc';
        defBox.style.borderRadius = '8px';
        defBox.style.background = '#f8f9ff';
        defBox.innerHTML = `<strong>Definition:</strong> ${defText}`;
        $hintArea.appendChild(defBox);

        {
  const list = new Set(JSON.parse(localStorage.getItem('learnedWords') || '[]'));
  if (entry.word) list.delete(entry.word);     // ensure NOT learned if maxed out
  localStorage.setItem('learnedWords', JSON.stringify([...list]));
}

        const nextBtn = document.createElement('button');
        nextBtn.textContent = 'Next Word â†’';
        nextBtn.style.marginTop = '12px';
        nextBtn.style.padding = '10px 15px';
        nextBtn.style.borderRadius = '8px';
        nextBtn.style.background = '#1a73e8';
        nextBtn.style.color = '#fff';
        nextBtn.style.border = 'none';
        nextBtn.style.cursor = 'pointer';
        nextBtn.onclick = () => {
          currentIndex += 1;
          const total = Math.min(Number(localStorage.getItem('maxQuestions')) || 0,
                                 (JSON.parse(localStorage.getItem('shuffledWordIds')) || []).length);
          if (currentIndex >= total) window.location.href = 'learn-quiz-complete.html';
          else window.location.href = `learn-quiz.html?index=${currentIndex}`;
        };
        $hintArea.appendChild(nextBtn);
        return;
      }

      if (hintIndex < hintQueue.length - 1) hintIndex++;
      await showCurrentHint(entry, entry.word);
      optionBtns.forEach(b => b.classList.remove('disabled'));
    }

    document.addEventListener('DOMContentLoaded', async () => {
      const WORDS = await loadWords();

      // ---- Read the existing order; create only if missing (deep-link case) ----
      let selectedIds = [];
      try { selectedIds = JSON.parse(localStorage.getItem('selectedWordIds') || '[]'); } catch {}
      if (!Array.isArray(selectedIds) || !selectedIds.length) {
        selectedIds = Object.keys(WORDS).map(Number).filter(Number.isFinite);
        localStorage.setItem('selectedWordIds', JSON.stringify(selectedIds));
      }

      let wordOrder = JSON.parse(localStorage.getItem('shuffledWordIds') || 'null');
      if (!Array.isArray(wordOrder) || !wordOrder.length) {
        // Deep-link fallback: create once, but DO NOT reset at meaning page thereafter
        wordOrder = selectedIds.slice().sort(() => Math.random() - 0.5);
        localStorage.setItem('shuffledWordIds', JSON.stringify(wordOrder));
      }

      const maxQ = Math.min(
        Number(localStorage.getItem('maxQuestions')) || wordOrder.length || 5,
        wordOrder.length
      );
      const wordId = wordOrder[currentIndex];
      const entry = WORDS[String(wordId)] || {};
      const wordText = entry.word || `Word ${wordId}`;

      // Initial UI
      $currentWord.textContent = wordText;
      $progress.textContent = `Question ${currentIndex + 1} of ${maxQ}`;
      $speakBtn.style.display = 'none';

      // attempts per word
      if (wordId && Number.isFinite(wordId) && !attemptsMap[wordId]) setAttempts(wordId, 0);

      // Options
      const letters = ['a','b','c','d'];
      const allChoices = Array.isArray(entry.choices) ? entry.choices.slice(0,4) : [];
      const correctIdx = Number.isInteger(entry.correct_index) ? entry.correct_index : 0;
      const correctLetter = letters[correctIdx];

      $options.innerHTML = '';
      allChoices.forEach((choiceText, idx) => {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.textContent = `${letters[idx]}) ${choiceText}`;
        btn.onclick = () => checkAnswer(btn, letters[idx], correctLetter, wordId, entry);
        $options.appendChild(btn);
      });

      // Hint ranking & queue
      const ranked = await getRanked(wordId);
      hintQueue = ranked.filter(t => t !== 'dialogue' || !!entry.hints?.dialogue);
      if (!hintQueue.length) hintQueue = ["story","gif"]; // last resort

      hintIndex = 0;
      await showCurrentHint(entry, wordText);
    });
  </script>
  <script src="xp.js"></script>
  <script>
window.addEventListener('load', () => {
    const xpContainer = document.getElementById('xpDisplay');

    // 1. Let xp.js write the level + XP text
    renderXP('xpDisplay');

    // 2. Now inject the beautiful progress bar (it won't be overwritten anymore)
    if (!document.querySelector('.xp-progress')) {
        xpContainer.insertAdjacentHTML('beforeend', `
            <div class="xp-progress">
                <div class="xp-fill"></div>
            </div>
        `);
    }

    // 3. Finally fill the green bar
    if (typeof getXP === 'function' && typeof XP_PER_LEVEL === 'number') {
        const progress = (getXP() % XP_PER_LEVEL) / XP_PER_LEVEL * 100;
        const fill = document.querySelector('.xp-fill');
        if (fill) fill.style.width = progress + '%';
    }
});
</script>
</body>
</html>
